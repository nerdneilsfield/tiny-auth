# tiny-auth 配置示例
# 完整配置文档：https://github.com/nerdneilsfield/tiny-auth

# ===== 服务器配置 =====
[server]
port = "8080"              # 监听端口（可通过环境变量 PORT 覆盖）
auth_path = "/auth"        # ForwardAuth 端点路径
health_path = "/health"    # 健康检查端点路径
read_timeout = 5           # 读超时（秒）
write_timeout = 5          # 写超时（秒）

# ⚠️ SECURITY: Trusted Proxies Configuration
# 可信代理列表：只接受来自这些 IP/网络的 X-Forwarded-* headers
# 如果为空，则接受任何来源（生产环境不推荐！）
# 
# 示例：
#   - 单个 IP:    ["192.168.1.100"]
#   - CIDR 范围:  ["172.16.0.0/12", "10.0.0.0/8"]
#   - IPv6:       ["::1", "fe80::/10"]
#   - Docker:     ["172.16.0.0/12"]
#   - Kubernetes: ["10.0.0.0/8"]
#
# 为什么重要：
# 没有此配置，攻击者可以伪造 X-Forwarded-Host/For 来绕过策略！
# 
# 生产环境（Traefik 在 Docker 中）：
trusted_proxies = ["172.16.0.0/12"]

# 生产环境（Traefik 在特定主机）：
# trusted_proxies = ["192.168.1.100"]

# 开发环境（接受任何来源 - 不要用于生产！）：
# trusted_proxies = []

# ===== Header 配置 =====
[headers]
user_header = "X-Auth-User"           # 用户名 header
role_header = "X-Auth-Role"           # 角色 header
method_header = "X-Auth-Method"       # 认证方法 header
extra_headers = ["X-Auth-Timestamp"]  # 额外注入的 headers
include_jwt_metadata = false          # 是否包含 JWT 元数据 headers

# ===== 日志配置 =====
[logging]
format = "text"  # 日志格式: "json" 或 "text"
level = "info"   # 日志级别: "debug", "info", "warn", "error"

# ===== 速率限制配置 =====
# 防止暴力破解攻击
[rate_limit]
enabled = true       # 是否启用速率限制
max_attempts = 5     # 时间窗口内的最大尝试次数
window_secs = 60     # 时间窗口（秒）
ban_secs = 300       # 封禁时长（秒）- 超过限制后禁止访问的时长

# ===== Basic Auth 配置 =====
# 支持多个用户，每个用户有独立的角色

[[basic_auth]]
name = "admin-user"
user = "admin"
pass = "supersecret"              # 明文密码（支持 env:VAR_NAME 语法）
# pass_hash = "$2a$10$..."        # bcrypt 哈希密码（推荐，更安全）
roles = ["admin", "user"]
# 提示：生成 bcrypt 哈希
#   方法 1: tiny-auth hash-password "your-password"
#   方法 2: htpasswd -bnBC 10 "" "your-password" | tr -d ':'
#   方法 3: python3 -c 'import bcrypt; print(bcrypt.hashpw(b"password", bcrypt.gensalt(10)).decode())'

[[basic_auth]]
name = "dev-user"
user = "dev"
pass = "env:DEV_PASSWORD"         # 从环境变量读取密码
# pass_hash = "env:DEV_PASSWORD_HASH"  # 也可以从环境变量读取哈希
roles = ["developer"]

# ===== Bearer Token 配置 =====
# 支持静态 Bearer Token

[[bearer_token]]
name = "prod-token"
token = "sk-live-abc123xyz789"
roles = ["admin", "service"]

[[bearer_token]]
name = "test-token"
token = "env:TEST_TOKEN"          # 从环境变量读取
roles = ["readonly", "tester"]

# ===== API Key 配置 =====
# 支持通过 Authorization: ApiKey xxx 或 X-Api-Key header

[[api_key]]
name = "prod-key"
key = "ak_prod_xxx_secret"
roles = ["admin"]

[[api_key]]
name = "readonly-key"
key = "env:READONLY_API_KEY"
roles = ["readonly"]

# ===== JWT 配置 =====
# 可选：如果不配置则不支持 JWT
[jwt]
secret = "your-256-bit-secret-key-here-must-be-at-least-32-chars-long"
issuer = "auth-service"           # 期望的 issuer (iss claim)
audience = "api"                  # 期望的 audience (aud claim)
user_claim_name = "sub"           # 用户标识的 claim 名称（默认 "sub"）
                                  # 支持: "sub", "preferred_username", "email", "username" 等
                                  # 如果指定的 claim 不存在，会自动回退到 "sub"

# ===== 路由策略配置 =====
# 可选：基于 host/path/method 的细粒度认证控制

# 示例：公共 API 允许匿名访问
[[route_policy]]
name = "public-api"
host = "api.public.com"
path_prefix = "/public"
allow_anonymous = true

# 示例：Webhook 端点只允许特定 Bearer Token
[[route_policy]]
name = "webhook-endpoint"
host = "hooks.example.com"
path_prefix = "/webhook"
allowed_bearer_names = ["prod-token"]
inject_authorization = "Bearer upstream-webhook-token"  # 可选：注入上游 Authorization

# 示例：管理面板只允许 admin 用户
[[route_policy]]
name = "admin-panel"
host = "admin.example.com"
allowed_basic_names = ["admin-user"]
require_all_roles = ["admin"]

# 示例：内部 API 只允许 JWT
[[route_policy]]
name = "internal-api"
host = "internal.example.com"
jwt_only = true

# 示例：混合认证（要求特定角色）
[[route_policy]]
name = "mixed-auth"
host = "mixed.example.com"
require_any_role = ["admin", "service"]  # 必须有 admin 或 service 角色
